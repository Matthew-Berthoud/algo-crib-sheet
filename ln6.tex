
\textbf{6.1 Introduction}

Divide and Conquer = top-down, recursive

Dynamic Programming = bottom-up, tabular,
store results of sub-problems to avoid re-computing

Eg. Fibonacci is $O(n)$ with DP, instead of $\Theta(1.618^n)$ with D\&C, since it stores previous answers

\textbf{6.7 Memory functions}

Divide and Conquer = Only needed entries are computed, but some more than once

Dynamic Programming = All entries, needed or not, computed once

Compromise between D\&C and DP. Use recursion (D\&C), but check table before recurring to see it it was computed already.

\textbf{Tips from HW 9}

1. World Series: The recurrence relation takes the numbers of games away from winning that each team is at, and the "base case" is the series being over. Remember to think backwards like this sometimes.

2. Combinatorics: Determine all possible partitions (groups of equal numbers) (n), and then get number of possible orderings (n!)

3. Transforming strings: Trivial cases are when one of the strings is of length 0, since you just have to delete or add letters. Each case's steps are the min of previous cases plus 1 (if current letter different) or plus 0 (if cur letter same)

4. Parenthesizing expressions: Create boolean functions that return true if the substring can be parenthesized to each of the variables, and then assemble them.